export CLICOLOR=1
export EDITOR=vim
export VISUAL=vim
export HISTFILESIZE=10000
export HISTSIZE=10000
export HISTIGNORE="&:[ ]*:exit:l:ll:ls:histdel"
export LC_ALL="en_US.UTF-8"
export LESS="-# 60 -i -X -R"
export LSCOLORS=dxfxcxdxbxegedabagacad
export LS_COLORS='di=1;35:ln=35:ex=31:su=30;43:sg=30;43:tw=30;43:ow=30;43:'
export PAGER=less
if [[ -n "$TMUX" ]]; then
    export TERM=screen-256color
else
    export TERM=xterm-256color
fi
export PYTHONSTARTUP=$HOME/.pythonrc
export PYTHONPATH=.:$HOME/code/python
export GOPATH=$HOME/code/go
IFS=$'\t\n'

case $(uname) in
    Linux | CYGWIN*) alias ls='ls --color=auto';;
esac
alias l='ls'
alias ll='ls -l'
alias j='jobs'
alias ocaml='ledit -x -h ~/.ocaml_history ocaml'
alias irssi='TERM=screen-256color irssi'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'


shopt -s histappend checkwinsize cmdhist extglob
if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
    shopt -s globstar
fi
set bell-style none
set show-all-if-ambiguous on
set +o histexpand
if [[ "$-" == *i* ]]; then # interactive
    bind "\C-p":history-search-backward
    bind "\C-n":history-search-forward
    bind 'set revert-all-at-newline on'  # Disable persistent history changes.

    stty -ixon -ixoff  # Try to disable flow control
    ! uname | egrep -i '(cygwin|msys|mingw)' > /dev/null && ulimit -S -n 4096
fi


function prompt1 {
    local r="\[\e[31m\]" # red
    local g="\[\e[32m\]" # green
    local y="\[\e[33m\]" # yellow
    local p="\[\e[34m\]" # purple
    local reset="\[\e[0m\]"
    local sep="$y|"
    local status_cmd="\$(s=\$?; [[ \$s -ne 0 ]] && echo \"$r\$s$sep\")"
    local job_cmd="\$([[ \j -ne 0 ]] && echo \"$p\j$sep\")"
    local branch_cmd="\$(b=\$(gitBranch); [[ -n \"\$b\" ]] && echo \"$sep$g\$b\")"
    PS1="\[\a\]$status_cmd$job_cmd$g\w$branch_cmd$y\\\$$reset "
}
prompt1


# Override any distro completions.
complete -r  # remove all complete specs
# Complete directories, and if none are returned do the usual completion of
# environment variables and files.
complete -A directory -o bashdefault -o default cd
COMPLETE_DIR=/etc/bash_completion.d
for cmd in git; do
    [[ -r $COMPLETE_DIR/$cmd ]] && . $COMPLETE_DIR/$cmd
done
unset COMPLETE_DIR


# cd to a directory further up your path that contains the given pattern.
# Change to the parent directory if nothing given.
# eg, if pwd is /usr/local/bin, then running "up loc" will cd to /usr/local.
function up {
    if [[ $# -eq 0 ]]; then
        cd ..
        return
    fi
    [[ "$PWD" =~ .*$1[^/]*/ ]]
    cd "${BASH_REMATCH[0]}"
}

# Delete last command from history: histdel
# Delete from offset to end of history: histdel OFFSET
# Delete from offset to another offset: histdel OFFSET OFFSET
function histdel {
    local last=$(history | tail -n 1 | awk '{print $1}')
    local start=${1:-$last}
    local end=${2:-$((last+1))}
    while [[ $start -lt $end ]]; do
        history -d $start
        end=$((end-1))
    done
}

function normal-perms {
    find "${1:-.}" -type d -exec chmod 755 '{}' \; -o -type f -exec chmod 644 '{}' \;
}

# find files under current directory containing a pattern
function ff {
    pattern=${1:?No pattern given}; shift
    find . -iname "*${pattern}*" "$@" 2>/dev/null
}

# find files ending with a suffix
function suf {
    pattern=${1:?No pattern given}; shift
    find . -iname "*${pattern}" "$@" 2>/dev/null
}


function gitBranch {
    branch_name=$(git symbolic-ref -q HEAD 2>/dev/null || true)
    branch_name=${branch_name##refs/heads/}
    echo $branch_name
}

function gitTrackingBranch {
    git rev-parse --symbolic-full-name --abbrev-ref @{upstream}
}

# git add rebase continue
function garc {
    git add -u
    git rebase --continue
}

# git submodule update
function gsu {
    repoRoot=$(git rev-parse --show-toplevel)
    # execute in a subshell so we don't have to save the cwd
    (cd $repoRoot; git submodule update)
}


# usage: mrm pattern n
# Print the nth most-recently-modified filename that matches pattern. If
# pattern is a glob you'll probably want to quote it.
function mrm {
    local pattern=${1:?No pattern given.}; shift
    local n=${1:-1}; shift
    ls -1dt $pattern | sed -n -e "${n}p"
}

# screen attach
function sat {
    local hostname=${1:-localhost}
    if [[ "$hostname" == localhost ]]; then
        screen -xRR
    else
        ssh -t $hostname screen -xRR
    fi
}

# Generate a script to rename a bunch of files.
# Edit a list of destinations in an editor, then review the generated script
# before running it.
function edmv {
    local src=$(mktemp --tmpdir edmvsrc.XXXXXXX)
    local dst=$(mktemp --tmpdir edmvdst.XXXXXXX)
    local script=$(mktemp --tmpdir edmvscript.XXXXXXX)
    for f in "$@"; do echo "$f"; done > "$src"
    cp "$src" "$dst"
    "$EDITOR" "$dst"
    if [[ $(wc -l <"$src") -ne $(wc -l <"$dst") ]]; then
        printf "Line count mismatch between %s and %s\n" "$src" "$dst" 1>&2
        rm "$script"
        return 1;
    fi
    while true; do
        read a <&3 || break
        read b <&4 || break
        if [[ "$b" == "" ]]; then
            printf 'rm "%s"\n' "$a"
        else
            printf 'mv "%s" "%s"\n' "$a" "$b"
        fi
    done 3<"$src" 4<"$dst" >"$script"
    "$EDITOR" "$script"
    bash "$script"
    rm "$src" "$dst" "$script"
}

# note commit push
function ncp {
    git commit -am "update from $(hostname)" && git push
}

function timer {
    local dur=${1:?No duration given}
    local start=$(date +%s)
    local left=$dur
    while (( left > 0 )); do
        printf "\r%4d" $left
        sleep 1
        left=$((start + dur - $(date +%s)))
    done
    case $(uname) in
        Linux) aplay /usr/share/pommed/goutte.wav &>/dev/null;;
        CYGWIN*) cat "$(cygpath -W)/Media/chord.wav" > /dev/dsp;;
    esac
    # clear line and then echo bell to set urgent flag in window manager
    echo -en '\r\e[2K\a'
}

# Open in BackGround
function obg {
    nohup "$@" &> /dev/null & disown $!
}

[ -e $HOME/.bashrc.local ] && . $HOME/.bashrc.local
